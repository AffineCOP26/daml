diff --git a/haskell/cabal.bzl b/haskell/cabal.bzl
index d1e0133e..7cba2b05 100644
--- a/haskell/cabal.bzl
+++ b/haskell/cabal.bzl
@@ -86,7 +86,8 @@ def _cabal_tool_flag(tool):
         return "--with-{}={}".format(tool.basename, tool.path)
 
 def _make_path(hs, binaries):
-    return ":".join([binary.dirname for binary in binaries.to_list()])
+    path_list_sep = ";" if hs.toolchain.is_windows else ":"
+    return path_list_sep.join([binary.dirname for binary in binaries.to_list()])
 
 def _prepare_cabal_inputs(hs, cc, dep_info, cc_info, component, package_id, tool_inputs, tool_input_manifests, cabal, setup, srcs, flags, cabal_wrapper, package_database):
     """Compute Cabal wrapper, arguments, inputs."""
diff --git a/haskell/cabal_wrapper.bzl b/haskell/cabal_wrapper.bzl
index 4e32f2ad..025c503a 100644
--- a/haskell/cabal_wrapper.bzl
+++ b/haskell/cabal_wrapper.bzl
@@ -29,9 +29,11 @@ def _cabal_wrapper_impl(ctx):
             "%{runghc}": hs.tools.runghc.path,
             "%{ar}": ar,
             "%{cc}": hs_toolchain.cc_wrapper.executable.path,
+            "%{cc_unwrapped}": cc_toolchain.compiler_executable(),
             "%{unix_paths}": repr(unix_toolchain.paths),
             "%{strip}": cc_toolchain.strip_executable(),
             "%{is_windows}": str(hs.toolchain.is_windows),
+            "%{workspace}": ctx.workspace_name,
         },
     )
     return [DefaultInfo(
diff --git a/haskell/private/cabal_wrapper.py.tpl b/haskell/private/cabal_wrapper.py.tpl
index 80feb4c2..c0746375 100755
--- a/haskell/private/cabal_wrapper.py.tpl
+++ b/haskell/private/cabal_wrapper.py.tpl
@@ -16,6 +16,7 @@
 
 from __future__ import print_function
 
+from bazel_tools.tools.python.runfiles import runfiles as bazel_runfiles
 from contextlib import contextmanager
 from glob import glob
 import os
@@ -26,7 +27,9 @@ import subprocess
 import sys
 import tempfile
 
-debug = False
+debug = True
+
+path_list_sep = ":" if "%{is_windows}" != "True" else ";"
 
 def run(cmd, *args, **kwargs):
     if debug:
@@ -34,10 +37,46 @@ def run(cmd, *args, **kwargs):
         sys.stderr.flush()
     subprocess.call(cmd, *args, **kwargs)
 
+def find_exe(exe):
+    if os.path.isfile(exe):
+        path = os.path.abspath(exe)
+    else:
+        r = bazel_runfiles.Create()
+        path = r.Rlocation("/".join(["%{workspace}", exe]))
+        if not os.path.isfile(exe) and "%{is_windows}" == "True":
+            path = r.Rlocation("/".join(["%{workspace}", exe + ".exe"]))
+    if debug:
+        print("find_exe(%s) = %s" % (exe, path), file=sys.stderr)
+    return path
+
+def posix_path(path):
+    """Convert the given path to POSIX format.
+
+    On Unix this is a no-op. On Windows it converts Windows style paths to
+    POSIX style. E.g. `C:\\foo\\bar` to `/c/foo/bar`.
+
+    Assumes that the given path is absolute.
+    """
+    if "%{is_windows}" != "True":
+        return path
+    else:
+        input_path = path
+        drive, path = os.path.splitdrive(input_path)
+        path = path.replace("\\", "/")
+        if drive.startswith("\\\\?\\"):
+            drive = drive[len("\\\\?\\"):]
+        if len(drive) == 2 and drive[1] == ":":
+            drive_letter = drive[0].lower()
+            if not path.lower().startswith("/%s" % drive_letter):
+                path = "/%s%s" % (drive_letter, path)
+        if debug:
+            print("posix_path(%s) = %s" % (input_path, path), file=sys.stderr)
+        return path
+
 def canonicalize_path(path):
-    return ":".join([
+    return path_list_sep.join([
         os.path.abspath(entry)
-        for entry in path.split(":")
+        for entry in path.split(path_list_sep)
         if entry != ""
     ])
 
@@ -45,8 +84,8 @@ def canonicalize_path(path):
 os.environ["LD_LIBRARY_PATH"] = canonicalize_path(os.getenv("LD_LIBRARY_PATH", ""))
 os.environ["LIBRARY_PATH"] = canonicalize_path(os.getenv("LIBRARY_PATH", ""))
 
-base_path = ":".join(%{unix_paths})
-os.environ["PATH"] = canonicalize_path(os.getenv("EXTRA_PATH", "") + ":" + base_path)
+base_path = path_list_sep.join(%{unix_paths})
+os.environ["PATH"] = canonicalize_path(os.getenv("EXTRA_PATH", "") + path_list_sep + base_path)
 
 
 component = sys.argv.pop(1)
@@ -62,9 +101,9 @@ bindir = os.path.join(pkgroot, "bin")
 datadir = os.path.join(pkgroot, "{}_data".format(name))
 package_database = os.path.join(pkgroot, "{}.conf.d".format(name))
 
-runghc = os.path.join(execroot, r"%{runghc}")
-ghc = os.path.join(execroot, r"%{ghc}")
-ghc_pkg = os.path.join(execroot, r"%{ghc_pkg}")
+runghc = find_exe(r"%{runghc}")
+ghc = find_exe(r"%{ghc}")
+ghc_pkg = find_exe(r"%{ghc_pkg}")
 
 extra_args = []
 current_arg = sys.argv.pop(1)
@@ -75,9 +114,9 @@ del current_arg
 
 path_args = sys.argv[1:]
 
-ar = os.path.realpath("%{ar}")
-cc = os.path.realpath("%{cc}")
-strip = os.path.realpath("%{strip}")
+ar = find_exe("%{ar}")
+cc = find_exe("%{cc}")
+strip = find_exe("%{strip}")
 
 def recache_db():
     run([ghc_pkg, "recache", "--package-db=" + package_database])
@@ -96,12 +135,31 @@ def tmpdir():
         shutil.rmtree(distdir)
 
 with tmpdir() as distdir:
+    if "${is_windows}" == "True":
+        # Note, we cannot currently use cc_wrapper.exe on Windows because the
+        # solution to the following issue is not released, yet.
+        #   https://github.com/bazelbuild/bazel/issues/9390
+        # We can work around it by creating another thin wrapper.
+        cc_unwrapped = find_exe("${cc_unwrapped}")
+        cc_new = os.path.join([distdir, "cc_wrapper"])
+        src = open(os.path.join([distdir, "cc_wrapper.c"]), "w")
+        src.write("""\
+            #include <unistd.h>
+            #include <stdio.h>
+            int main(int argc, char **argv) {
+                const char *cc = "{cc}";
+                argv[0] = cc;
+                execv(cc, argv);
+                perror("Failed to execute cc_wrapper");
+                return 1;
+            }
+        """.format(cc = cc))
+        run([cc_unwrapped, "-o", cc_new, src])
+        cc = cc_new
+
     # Use the cc-wrapper for Cabal builds.
-    # Note, we cannot currently use it on Windows because the solution to the
-    # following issue is not released, yet.
-    #   https://github.com/bazelbuild/bazel/issues/9390
-    with_gcc_flags = ["--with-gcc=" + cc] \
-            if "%{is_windows}" != "True" else []
+    with_gcc_flags = ["--with-gcc=" + cc]
+
     enable_relocatable_flags = ["--enable-relocatable"] \
             if "%{is_windows}" != "True" else []
 
@@ -169,7 +227,7 @@ def make_relocatable_paths(line):
 
     # The $execroot is an absolute path and should not leak into the output.
     # Replace each ocurrence of execroot by a path relative to ${pkgroot}.
-    line = re.sub(execroot + '\S*', make_relative_to_pkgroot, line)
+    line = re.sub(re.escape(execroot) + '\S*', make_relative_to_pkgroot, line)
     return line
 
 if libraries != [] and os.path.isfile(package_conf_file):
diff --git a/haskell/private/unix/unix_configure.bzl b/haskell/private/unix/unix_configure.bzl
index 112d74e7..87221143 100644
--- a/haskell/private/unix/unix_configure.bzl
+++ b/haskell/private/unix/unix_configure.bzl
@@ -43,7 +43,10 @@ toolchain(
             for (cmd, cmd_path) in commands.items()
             if cmd_path
         ]),
-        os = "osx" if cpu == "darwin" else "linux",
+        os = {
+            "darwin": "osx",
+            "x64_windows": "windows",
+        }.get(cpu, "linux"),
     ))
 
 unix_config = repository_rule(
