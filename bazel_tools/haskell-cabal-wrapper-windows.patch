diff --git a/haskell/BUILD.bazel b/haskell/BUILD.bazel
index 0c0fbebe..2688b37a 100644
--- a/haskell/BUILD.bazel
+++ b/haskell/BUILD.bazel
@@ -36,6 +36,11 @@ cc_wrapper(
     visibility = ["//visibility:public"],
 )
 
+cc_wrapper(
+    name = "cc_wrapper_proto",
+    visibility = ["//visibility:public"],
+)
+
 cabal_wrapper(
     name = "cabal_wrapper",
     visibility = ["//visibility:public"],
diff --git a/haskell/cabal.bzl b/haskell/cabal.bzl
index b8b68074..e4931f6b 100644
--- a/haskell/cabal.bzl
+++ b/haskell/cabal.bzl
@@ -89,43 +89,66 @@ def _binary_paths(binaries):
     return [binary.dirname for binary in binaries.to_list()]
 
 def _skip_ghc_bindist(path):
-    if path.find("rules_haskell_ghc_windows_amd64") != -1:
+    if path.find("ghc_windows_amd64") != -1:
         return None
     else:
         return path
 
-def _prepare_cabal_inputs(hs, cc, posix, dep_info, cc_info, component, package_id, tool_inputs, tool_input_manifests, cabal, setup, srcs, flags, cabal_wrapper, package_database):
+def _prepare_cabal_inputs(hs, cc, posix, dep_info, direct_cc_info, cc_info, component, package_id, tool_inputs, tool_input_manifests, cabal, setup, srcs, flags, cabal_wrapper, package_database):
     """Compute Cabal wrapper, arguments, inputs."""
     with_profiling = is_profiling_enabled(hs)
 
-    (ghci_extra_libs, env) = get_ghci_extra_libs(hs, posix, cc_info)
+    (direct_libs, _) = get_ghci_extra_libs(hs, posix, direct_cc_info)
+    (transitive_libs, env) = get_ghci_extra_libs(hs, posix, cc_info)
     env.update(**hs.env)
-    env["PATH"] = join_path_list(hs, _binary_paths(tool_inputs) + posix.paths)
+    if hs.label.workspace_name == "proto3_suite":
+        cc_path = paths.dirname(cc.tools.cpp)
+        print("cc_path", cc_path)
+        env["PATH"] = join_path_list(hs, _binary_paths(tool_inputs) + posix.paths + [cc_path])
+        env["TMPDIR"] = "./_tmp"
+    else:
+        env["PATH"] = join_path_list(hs, _binary_paths(tool_inputs) + posix.paths)
     if hs.toolchain.is_darwin:
         env["SDKROOT"] = "macosx"  # See haskell/private/actions/link.bzl
 
     args = hs.actions.args()
     package_databases = dep_info.package_databases
-    extra_headers = cc_info.compilation_context.headers
-    extra_include_dirs = depset(transitive = [
-        cc_info.compilation_context.includes,
-        cc_info.compilation_context.quote_includes,
-        cc_info.compilation_context.system_includes,
+    transitive_headers = cc_info.compilation_context.headers
+    direct_include_dirs = depset(transitive = [
+        direct_cc_info.compilation_context.includes,
+        direct_cc_info.compilation_context.quote_includes,
+        direct_cc_info.compilation_context.system_includes,
     ])
-    extra_lib_dirs = [
-        file.dirname
-        for file in ghci_extra_libs.to_list()
-        # Exclude Haskell libraries, as these are already covered by
-        # package-dbs. This is to avoid command-line length overflow on
-        # collect2.
-        if not file.basename.startswith("libHS")
-    ]
+    direct_lib_dirs = [file.dirname for file in direct_libs.to_list()]
     args.add_all([component, package_id, setup, cabal.dirname, package_database.dirname])
     args.add("--flags=" + " ".join(flags))
+    if hs.label.workspace_name == "proto3_suite":
+        execroot = "C:/users/admin/_bazel_admin/oaoes6io/execroot/com_github_digital_asset_daml/"
+        cc_wrapper_proto = hs.toolchain.cc_wrapper_proto
+        args.add_all([
+            # GHC uses C compiler for assemly, linking and preprocessing as well.
+            "-pgma",
+            execroot + cc_wrapper_proto.executable.path,
+            "-pgmc",
+            execroot + cc_wrapper_proto.executable.path,
+            "-pgml",
+            execroot + cc_wrapper_proto.executable.path,
+            "-pgmP",
+            execroot + cc_wrapper_proto.executable.path,
+            # Setting -pgm* flags explicitly has the unfortunate side effect
+            # of resetting any program flags in the GHC settings file. So we
+            # restore them here. See
+            # https://ghc.haskell.org/trac/ghc/ticket/7929.
+            "-optc-fno-stack-protector",
+            "-optP-E",
+            "-optP-undef",
+            "-optP-traditional",
+        ], format_each = "--ghc-option=%s")
+        args.add_all(["-v", "-keep-tmp-files"], format_each = "--ghc-option=%s")
     args.add("--")
     args.add_all(package_databases, map_each = _dirname, format_each = "--package-db=%s")
-    args.add_all(extra_include_dirs, map_each = _skip_ghc_bindist, format_each = "--extra-include-dirs=%s")
-    args.add_all(extra_lib_dirs, format_each = "--extra-lib-dirs=%s", uniquify = True)
+    args.add_all(direct_include_dirs, map_each = _skip_ghc_bindist, format_each = "--extra-include-dirs=%s")
+    args.add_all(direct_lib_dirs, map_each = _skip_ghc_bindist, format_each = "--extra-lib-dirs=%s", uniquify = True)
     if with_profiling:
         args.add("--enable-profiling")
 
@@ -138,13 +161,15 @@ def _prepare_cabal_inputs(hs, cc, posix, dep_info, cc_info, component, package_i
             depset(srcs),
             depset(cc.files),
             package_databases,
-            extra_headers,
-            ghci_extra_libs,
+            transitive_headers,
+            transitive_libs,
             dep_info.interface_dirs,
             dep_info.static_libraries,
             dep_info.dynamic_libraries,
             tool_inputs,
-        ],
+        ] + ([
+            hs.toolchain.cc_wrapper_proto.inputs
+        ] if hs.label.workspace_name == "proto3_suite" else []),
     )
     input_manifests = tool_input_manifests
 
@@ -160,8 +185,19 @@ def _haskell_cabal_library_impl(ctx):
     hs = haskell_context(ctx)
     dep_info = gather_dep_info(ctx, ctx.attr.deps)
     cc = cc_interop_info(ctx)
+    direct_cc_info = cc_common.merge_cc_infos(
+        cc_infos = [
+            dep[CcInfo]
+            for dep in ctx.attr.deps
+            if CcInfo in dep and not HaskellInfo in dep
+        ],
+    )
     cc_info = cc_common.merge_cc_infos(
-        cc_infos = [dep[CcInfo] for dep in ctx.attr.deps if CcInfo in dep],
+        cc_infos = [
+            dep[CcInfo]
+            for dep in ctx.attr.deps
+            if CcInfo in dep
+        ],
     )
     posix = ctx.toolchains["@rules_sh//sh/posix:toolchain_type"]
     package_id = "{}-{}".format(
@@ -208,6 +244,7 @@ def _haskell_cabal_library_impl(ctx):
         cc,
         posix,
         dep_info,
+        direct_cc_info,
         cc_info,
         component = "lib:{}".format(
             ctx.attr.package_name if ctx.attr.package_name else hs.label.name,
@@ -363,8 +400,19 @@ def _haskell_cabal_binary_impl(ctx):
     hs = haskell_context(ctx)
     dep_info = gather_dep_info(ctx, ctx.attr.deps)
     cc = cc_interop_info(ctx)
+    direct_cc_info = cc_common.merge_cc_infos(
+        cc_infos = [
+            dep[CcInfo]
+            for dep in ctx.attr.deps
+            if CcInfo in dep and not HaskellInfo in dep
+        ],
+    )
     cc_info = cc_common.merge_cc_infos(
-        cc_infos = [dep[CcInfo] for dep in ctx.attr.deps if CcInfo in dep],
+        cc_infos = [
+            dep[CcInfo]
+            for dep in ctx.attr.deps
+            if CcInfo in dep
+        ],
     )
     posix = ctx.toolchains["@rules_sh//sh/posix:toolchain_type"]
 
@@ -391,6 +439,7 @@ def _haskell_cabal_binary_impl(ctx):
         cc,
         posix,
         dep_info,
+        direct_cc_info,
         cc_info,
         component = "exe:{}".format(hs.label.name),
         package_id = hs.label.name,
diff --git a/haskell/ghc_bindist.bzl b/haskell/ghc_bindist.bzl
index 584ca8af..c5840806 100644
--- a/haskell/ghc_bindist.bzl
+++ b/haskell/ghc_bindist.bzl
@@ -442,7 +442,7 @@ def haskell_register_ghc_bindists(
         fail("Binary distribution of GHC {} not available.".format(version))
     for target in GHC_BINDIST[version]:
         ghc_bindist(
-            name = "rules_haskell_ghc_{}".format(target),
+            name = "ghc_{}".format(target),
             target = target,
             version = version,
             compiler_flags = compiler_flags,
diff --git a/haskell/private/cc_wrapper.bzl b/haskell/private/cc_wrapper.bzl
index f39c6b5f..4541993e 100644
--- a/haskell/private/cc_wrapper.bzl
+++ b/haskell/private/cc_wrapper.bzl
@@ -50,7 +50,7 @@ _cc_wrapper = rule(
 def cc_wrapper(name, **kwargs):
     _cc_wrapper(
         name = name + ".py",
-        template = "@rules_haskell//haskell:private/cc_wrapper.py.tpl",
+        template = "@rules_haskell//haskell:private/%s.py.tpl" % name,
         platform = select({
             "@rules_haskell//haskell/platforms:darwin": "darwin",
             "@rules_haskell//haskell/platforms:mingw32": "windows",
@@ -59,7 +59,7 @@ def cc_wrapper(name, **kwargs):
     )
     _cc_wrapper(
         name = name + ".sh",
-        template = "@rules_haskell//haskell:private/cc_wrapper_windows.sh.tpl",
+        template = "@rules_haskell//haskell:private/%s_windows.sh.tpl" % name,
         platform = select({
             "@rules_haskell//haskell/platforms:darwin": "darwin",
             "@rules_haskell//haskell/platforms:mingw32": "windows",
diff --git a/haskell/private/cc_wrapper_proto_windows.sh.tpl b/haskell/private/cc_wrapper_proto_windows.sh.tpl
new file mode 100644
index 00000000..b1524cd9
--- /dev/null
+++ b/haskell/private/cc_wrapper_proto_windows.sh.tpl
@@ -0,0 +1,202 @@
+# CC toolchain wrapper
+#
+# Usage: cc_wrapper [ARG]...
+#
+# Wraps the C compiler of the Bazel CC toolchain. Transforms arguments to work
+# around limitations of Bazel and GHC and passes those via response file to the C
+# compiler.
+#
+# - Shortens library search paths to stay below maximum path length on Windows.
+#
+#     GHC generates library search paths that contain redundant up-level
+#     references (..). This can exceed the maximum path length on Windows, which
+#     will cause linking failures. This wrapper shortens library search paths to
+#     avoid that issue.
+#
+# - Shortens include paths to stay below maximum path length.
+#
+#     GHC generates include paths that contain redundant up-level
+#     references (..). This can exceed the maximum path length, which
+#     will cause compiler failures. This wrapper shortens include paths
+#     to avoid that issue.
+
+# The runfiles.bash initialization triggers "Can't follow non-constant source".
+# Disabling the warning locally is insufficient, so we disable it globally.
+# shellcheck disable=SC1090
+
+set -euo pipefail
+
+debug() {
+    echo "$*" >> "/c/users/admin/cc_wrapper_proto.log"
+}
+
+# ----------------------------------------------------------
+# Find compiler
+
+find_exe() {
+    local -n location="$1"
+    local exe="$2"
+
+    location="$exe"
+    if [[ -f "$location" ]]; then
+        return
+    fi
+
+    location="${exe}.exe"
+    if [[ -f "$location" ]]; then
+        return
+    fi
+
+    # --- begin runfiles.bash initialization v2 ---
+    # Copy-pasted from the Bazel Bash runfiles library v2.
+    set -uo pipefail; f=bazel_tools/tools/bash/runfiles/runfiles.bash
+    source "${RUNFILES_DIR:-/dev/null}/$f" 2>/dev/null || \
+      source "$(grep -sm1 "^$f " "${RUNFILES_MANIFEST_FILE:-/dev/null}" | cut -f2- -d' ')" 2>/dev/null || \
+      source "$0.runfiles/$f" 2>/dev/null || \
+      source "$(grep -sm1 "^$f " "$0.runfiles_manifest" | cut -f2- -d' ')" 2>/dev/null || \
+      source "$(grep -sm1 "^$f " "$0.exe.runfiles_manifest" | cut -f2- -d' ')" 2>/dev/null || \
+      { echo>&2 "ERROR: cannot find $f"; exit 1; }; f=; set -e
+    # --- end runfiles.bash initialization v2 ---
+
+    location="$(rlocation "{:workspace:}/$exe")"
+    if [[ -f "$location" ]]; then
+        return
+    fi
+
+    location="$(rlocation "{:workspace:}/${exe}.exe")"
+    if [[ -f "$location" ]]; then
+        return
+    fi
+}
+
+declare CC
+find_exe CC "{:cc:}"
+
+# ----------------------------------------------------------
+# Handle response file
+
+RESPONSE_FILE="$(mktemp rspXXXX)"
+rm_response_file() {
+    rm -f "$RESPONSE_FILE"
+}
+trap rm_response_file EXIT
+
+quote_arg() {
+    # Gcc expects one argument per line, surrounded by double quotes, with
+    # inner double quotes escaped with backslash, and backslashes themselves
+    # escaped.
+    local arg="$1"
+    arg="${arg//\\/\\\\}"
+    arg="${arg//\"/\\\"}"
+    printf '"%s"\n' "$arg"
+}
+
+unquote_arg() {
+    local -n output="$1"
+    local input="$2"
+    if [[ "$input" =~ ^\"(.*)\"[[:space:]]*$ ]]; then
+        input="${BASH_REMATCH[1]}"
+        input="${input//\\\"/\"}"
+        input="${input//\\\\/\\}"
+    fi
+    # shellcheck disable=SC2034
+    # nameref assignment is a "variable use"
+    # https://github.com/koalaman/shellcheck/issues/1543
+    output="$input"
+}
+
+add_arg() {
+    quote_arg "$1" >> "$RESPONSE_FILE"
+    debug "> '$(quote_arg "$1")'"
+}
+
+# ----------------------------------------------------------
+# Parse arguments
+
+IN_RESPONSE_FILE=
+INCLUDE_DIR_COMING=
+INCLUDE_FLAG=
+LIB_DIR_COMING=
+
+shorten_path() {
+    local -n shortest="$1"
+    local input="$2"
+
+    shortest="$input"
+    if [[ ! -e "$shortest" ]]; then
+        # realpath fails if the file does not exist.
+        return
+    fi
+
+    local normalized
+    normalized="$(realpath "$shortest")"
+    if [[ ${#normalized} -lt ${#shortest} ]]; then
+        shortest="$normalized"
+    fi
+
+    local relative
+    relative="$(realpath --relative-to="$PWD" "$shortest")"
+    if [[ ${#relative} -lt ${#shortest} ]]; then
+        shortest="$relative"
+    fi
+}
+
+handle_include_dir() {
+    local flag="$1"
+    local include_dir="$2"
+    local shortened
+    shorten_path shortened "$include_dir"
+    add_arg "$flag$shortened"
+}
+
+handle_lib_dir() {
+    local lib_dir="$1"
+    local shortened
+    shorten_path shortened "$lib_dir"
+    add_arg "-L$shortened"
+}
+
+handle_arg() {
+    local arg="$1"
+    if [[ $IN_RESPONSE_FILE = 1 ]]; then
+        unquote_arg arg "$arg"
+    fi
+    if [[ $INCLUDE_DIR_COMING = 1 ]]; then
+        INCLUDE_DIR_COMING=
+        INCLUDE_FLAG=
+        handle_include_dir "$INCLUDE_FLAG" "$arg"
+    elif [[ $LIB_DIR_COMING = 1 ]]; then
+        LIB_DIR_COMING=
+        handle_lib_dir "$arg"
+    elif [[ "$arg" =~ ^@(.*)$ ]]; then
+        IN_RESPONSE_FILE=1
+        while read -r line; do
+            handle_arg "$line"
+        done < "${BASH_REMATCH[1]}"
+        IN_RESPONSE_FILE=
+    elif [[ "$arg" =~ ^(-I|-iquote|-isystem|-idirafter)(.*)$ ]]; then
+        handle_include_dir "${BASH_REMATCH[1]}" "${BASH_REMATCH[2]}"
+    elif [[ "$arg" = -I || "$arg" = -iquote || "$arg" = -isystem || "$arg" = -idirafter ]]; then
+        INCLUDE_DIR_COMING=1
+        INCLUDE_FLAG="$arg"
+    elif [[ "$arg" =~ ^-L(.*)$ || "$arg" =~ ^--library-path=(.*)$ ]]; then
+        handle_lib_dir "${BASH_REMATCH[1]}"
+    elif [[ "$arg" = -L || "$arg" = --library-path ]]; then
+        LIB_DIR_COMING=1
+    else
+        add_arg "$arg"
+    fi
+}
+
+for arg in "$@"; do
+    debug "< '$arg'"
+    handle_arg "$arg"
+done
+
+# ----------------------------------------------------------
+# Call compiler
+
+export PATH="$PATH;/c/Users/Admin/_bazel_Admin/oaoes6io/external/ghc_windows_amd64/mingw/lib/gcc/x86_64-w64-mingw32/7.2.0"
+"$(/c/users/admin/dadew/scoop/shims/cygpath.exe -u "$CC")" "@$RESPONSE_FILE"
+
+# vim: ft=sh
diff --git a/haskell/toolchain.bzl b/haskell/toolchain.bzl
index 8482beef..9d115ea8 100644
--- a/haskell/toolchain.bzl
+++ b/haskell/toolchain.bzl
@@ -155,6 +155,11 @@ def _haskell_toolchain_impl(ctx):
     cc_wrapper_runfiles = cc_wrapper_info.default_runfiles.merge(
         cc_wrapper_info.data_runfiles,
     )
+    (cc_wrapper_proto_inputs, cc_wrapper_proto_manifest) = ctx.resolve_tools(tools = [ctx.attr._cc_wrapper_proto])
+    cc_wrapper_proto_info = ctx.attr._cc_wrapper_proto[DefaultInfo]
+    cc_wrapper_proto_runfiles = cc_wrapper_proto_info.default_runfiles.merge(
+        cc_wrapper_proto_info.data_runfiles,
+    )
 
     return [
         platform_common.ToolchainInfo(
@@ -171,6 +176,12 @@ def _haskell_toolchain_impl(ctx):
                 manifests = cc_wrapper_manifest,
                 runfiles = cc_wrapper_runfiles,
             ),
+            cc_wrapper_proto = struct(
+                executable = ctx.executable._cc_wrapper_proto,
+                inputs = cc_wrapper_proto_inputs,
+                manifests = cc_wrapper_proto_manifest,
+                runfiles = cc_wrapper_proto_runfiles,
+            ),
             mode = ctx.var["COMPILATION_MODE"],
             actions = struct(
                 compile_binary = compile_binary,
@@ -240,6 +251,11 @@ Label pointing to the locale archive file to use. Mostly useful on NixOS.
             default = Label("@rules_haskell//haskell:cc_wrapper"),
             executable = True,
         ),
+        "_cc_wrapper_proto": attr.label(
+            cfg = "host",
+            default = Label("@rules_haskell//haskell:cc_wrapper_proto"),
+            executable = True,
+        ),
     },
 )
 
diff --git a/hazel/tools/ghc.bzl b/hazel/tools/ghc.bzl
index e359021b..50552b2d 100644
--- a/hazel/tools/ghc.bzl
+++ b/hazel/tools/ghc.bzl
@@ -3,7 +3,7 @@ load("@bazel_tools//tools/cpp:lib_cc_configure.bzl", "get_cpu_value")
 default_ghc_workspaces = {
     "k8": "@ghc",
     "darwin": "@ghc",
-    "x64_windows": "@rules_haskell_ghc_windows_amd64",
+    "x64_windows": "@ghc_windows_amd64",
 }
 
 def get_ghc_workspace(ghc_workspaces, repository_ctx):
