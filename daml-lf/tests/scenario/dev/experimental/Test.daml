-- Copyright (c) 2021 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Test where

import DA.Experimental.Example
import qualified DA.Experimental.BigNumeric as BN
import qualified DA.Experimental.RoundingMode as Rounding
import qualified DA.List as L
import DA.Experimental.Log
import qualified DA.Numeric as Numeric

type BN = BN.BigNumeric

m = 1000
n = 16
s = 4

-- pretty bad pseudo random generator
nextInt: Int -> Int
nextInt seed = (seed * 2147483629 + 2147483587) % 1000000000 ;

makeIntList: Int -> Int -> [Int] -> (Int, [Int])
makeIntList seed 0 acc = (seed, acc)
makeIntList seed n acc =
    makeIntList nextSeed (n-1) (nextSeed :: acc)
  where nextSeed = nextInt seed

makeIntListList: Int -> Int -> Int -> [[Int]]-> (Int, [[Int]])
makeIntListList seed 0 _ acc = (seed, acc)
makeIntListList seed n m acc =
    makeIntListList nextSeed (n-1) m (l :: acc)
  where
    (nextSeed, l) = makeIntList seed m []

init_element:  (Int -> a) -> (a -> a -> a) -> (a -> a -> a) -> [Int] -> a
init_element fromInt add mult l =
     (L.foldl (\x i -> add (mult x billion) (fromInt i)) zero) l
   where
     zero = fromInt 0
     billion = fromInt 1000000000

init_list:  (Int -> a) -> (a -> a -> a) -> (a -> a -> a) -> [[Int]] -> [a]
init_list fromInt add mult l =
  map (init_element fromInt add mult) l

sumProduct: (Int -> a) -> (a -> a -> a) -> (a -> a -> a) -> [a] -> [a] -> a
sumProduct fromInt add mult l1 l2 =
    L.foldl (\x tuple -> add x (mult (fst tuple) (snd tuple))) zero (L.zip l1 l2)
  where
    zero = fromInt 0

---

fromInt: Int -> BN
fromInt i = BN.fromNumeric ((intToNumeric i): Numeric 0)

one = fromInt 1
ten = fromInt 10

add, mult: BN -> BN -> BN
add = BN.add
mult = BN.multiply

l1 = map (BN.shift (-s*n)) $ init_list fromInt add mult $ snd $ makeIntListList 0 m n []
l2 = map (BN.shift (-s*n)) $ init_list fromInt add mult $ snd $ makeIntListList 1 m n []

run2 = scenario do assert $ (show result) == expectedResult
  where
    result = sumProduct fromInt add mult l1 l2
    _ = log (show result)
    expectedResult =
      -- when m = 1
      -- "1450217779520750740114092380580385102254679792467957306117851438396993788199700305751646428787424195732704751052050966978275850133986934529263614704650144019569.20833148101522975056791659892644969632853668544525204891091757299111295248528097097528474679896104565590131733691455520063083792"
      -- when m = 1000
      "2452480261697618782037651040173687334078043709917566298246607061482061240357147437008275001199990643139763813080367109990237870262202299888046550575279784694841354.09085623238906136263283348635971139821404128423336932627714970176849009427033491200991325895319635198030635240154820650021432000"


run = scenario do
    assert ("1000.000000" == (show bX))
  where
    a: Numeric 2
    a = 10.0
    b: Numeric 3
    b = 100.0
    x: Numeric 6
    x = Numeric.mul Rounding.Unnecessary a b
    bX = BN.fromNumeric x