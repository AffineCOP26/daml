-- Copyright (c) 2021 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# LANGUAGE CPP #-}

module DA.Numeric where

#ifdef DAML_EXPERIMENTAL
import qualified DA.Experimental.BigNumeric as BN
import DA.Experimental.RoundingMode
import GHC.Types (Nat)



reify: NumericScale n3 => forall n. Int
reify = primitive @"$TO_INT_NAT"

multiply : forall n1 n2 n3. NumericScale n3 => RoundingMode -> Numeric n1 -> Numeric n2 -> Numeric n3
multiply rounding x y =
    BN.toNumeric $ BN.setScale scale rounding $ BN.multiply bY bX
  where
    scale = reify @n3
    bX = BN.fromNumeric x
    bY = BN.fromNumeric y

divide : forall n1 n2 n3. NumericScale n3 => RoundingMode -> Numeric n1 -> Numeric n2 -> Numeric n3
divide rounding x y =
    BN.toNumeric $ BN.divide scale rounding bY bX
  where
    scale = reify @n3
    bX = BN.fromNumeric x
    bY = BN.fromNumeric y

cast : forall n2 n1. NumericScale n2 => Numeric n1 -> Numeric n2
cast x = BN.toNumeric $ BN.fromNumeric x

roundAndCast: forall n2 n1. NumericScale n2 => RoundingMode -> Numeric n1 -> Numeric n2
roundAndCast rounding x =
    BN.toNumeric $ BN.setScale scale rounding bX
  where
    scale = reify @n3
    bX = BN.fromNumeric x

shift : forall n2 n1. NumericScale n1 => NumericScale n2 => Numeric n1 -> Numeric n2
shift x =
   BN.toNumeric $ BN.shift shifting bX
 where
   shifting = (reify @n2) - (reify @n1)
   bX = BN.fromNumeric x

pi : forall n. NumericScale n => Numeric n
pi = roundAndCast HalfUp (3.14159_26535_89793_23846_26433_83279_50288_41 : Numeric 37)

#elifdef DAML_NUMERIC

import GHC.Types (primitive)

-- | Multiply two numerics. Both inputs and the output may have
-- different scales, unlike `(*)` which forces all numeric scales
-- to be the same. Raises an error on overflow, rounds to chosen
-- scale otherwise.
mul : forall n3 n1 n2. NumericScale n3 => Numeric n1 -> Numeric n2 -> Numeric n3
mul = primitive @"BEMulNumeric"

-- | Divide two numerics. Both inputs and the output may have
-- different scales, unlike `(/)` which forces all numeric scales
-- to be the same. Raises an error on overflow, rounds to chosen
-- scale otherwise.
div : forall n3 n1 n2. NumericScale n3 => Numeric n1 -> Numeric n2 -> Numeric n3
div = primitive @"BEDivNumeric"

-- | Cast a Numeric. Raises an error on overflow or loss of precision.
cast : forall n2 n1. NumericScale n2 => Numeric n1 -> Numeric n2
cast = primitive @"BECastNumeric"

-- | Cast a Numeric. Raises an error on overflow, rounds to chosen
-- scale otherwise.
castAndRound : forall n2 n1. NumericScale n2 => Numeric n1 -> Numeric n2
castAndRound = mul (1.0 : Numeric 0)

-- | Move the decimal point left or right by multiplying the numeric
-- value by 10^(n1 - n2). Does not overflow or underflow.
shift : forall n2 n1. NumericScale n2 => Numeric n1 -> Numeric n2
shift = primitive @"BEShiftNumeric"

-- | The number pi.
pi : forall n. NumericScale n => Numeric n
pi = castAndRound (3.14159_26535_89793_23846_26433_83279_50288_41 : Numeric 37)

#else

-- | The number pi.
pi : Decimal
pi = 3.14159_26536

#endif
