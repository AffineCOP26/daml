-- Copyright (c) 2021 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0



module DA.Experimental.BigNumeric (
      BigNumeric
    , add
    , compare
    , divide
    , fromNumeric
    , multiply
    , one
    , precision
    , scale
    , setScale
    , shift
    , subtract
    , toNumeric
    , toText
    , zero
) where

import GHC.Types (Nat, primitive)
import DA.Experimental.RoundingMode
import Prelude hiding (compare, round, subtract, toText)


-- A BigNumeric is basically a java BigDecimal with the extra constraint
-- that scale and precision are explicitly bounded.
-- In the current implementation we have
--  - 0 < precsion < MaxPrecision
--  - 0 <= scale < MaxScale
data BigNumeric

data Proxy (n : GHC.Types.Nat) = Proxy {}

instance Show BigNumeric where
    show = toText
instance Eq BigNumeric where
    x ==  y = (compare x y) == EQ

fromNumeric: forall n. Numeric n -> BigNumeric
fromNumeric = primitive @"$FROM_NUMERIC_BIGNUMERIC"

toNumeric: forall n. NumericScale n => BigNumeric -> Numeric n
 -- The scale is pass explicitly because experimental builtins ignore type quantifiers
toNumeric = primitive @"$TO_NUMERIC_BIGNUMERIC" scale
  where
    scale = numericScale (Proxy : Proxy n)

zero, one: BigNumeric
zero = fromNumeric (0.0 : Numeric 0)
one = fromNumeric (1.0 : Numeric 0)

scale, precision: BigNumeric -> Int
scale = primitive @"$SCALE_BIGNUMERIC"
precision = primitive @"$PRECISION_BIGNUMERIC"

-- can overflow
-- scale (add x y) == min (scale x) (scale y)
add, subtract: BigNumeric -> BigNumeric -> BigNumeric
add = primitive @"$ADD_BIGNUMERIC"
subtract = primitive @"$SUB_BIGNUMERIC"

-- can under/overflow
-- scale (mul x y) == (scale x) + (scale y)
multiply: BigNumeric -> BigNumeric -> BigNumeric
multiply = primitive @"$MULT_BIGNUMERIC"

divide: Int -> RoundingMode -> BigNumeric -> BigNumeric -> BigNumeric
divide = primitive @"$DIV_BIGNUMERIC"

setScale: Int -> RoundingMode -> BigNumeric -> BigNumeric
setScale scale rounding x = divide scale rounding x one

-- sensitive to scale
toText: BigNumeric -> Text
toText = primitive @"$TO_TEXT_BIGNUMERIC"

-- in final version we will use standard LF-buitlin comparisons
compare: BigNumeric -> BigNumeric ->  Ordering
compare = primitive @"$COMPARE_BIGNUMERIC"

-- ! can overflow !
-- like in java
stripTrailingZero: BigNumeric -> BigNumeric
stripTrailingZero = primitive @"$STRIP_TRAILING_ZERO_BIGNUMERIC"

-- can under/overflow
shift: Int -> BigNumeric -> BigNumeric
shift = primitive @"$SHIFT_BIGNUMERIC"

