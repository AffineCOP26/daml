-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0


module Rule where

import DA.Action
import DA.Action.State.Class
import DA.Assert
import qualified DA.Next.Map as Map
import Daml.Trigger
import Daml.Trigger.Assert
import qualified Daml.Script as Script

template T
  with
    party : Party
    count : Int
  where
    signatory party
    key (party, count) : (Party, Int)
    maintainer key._1

    nonconsuming choice Poke : ()
      with
        n : Int
      controller party
        do
          pure ()

trigger : Trigger Int
trigger = Trigger with
  initialize = pure 0
  updateState = \_msg -> put . length =<< query @T
  rule = \party -> do
    count <- get
    when (count == 1) do
      priorCIF <- getCommandsInFlight
      -- Create two additional T.
      dedupCreate T with party, count
      dedupCreate T with party, count = succ count
      -- Exercise a choice
      ts <- query @T
      let [(tId, _)] = ts
      dedupExercise tId Poke with n = 0
      -- Exercise a choice by key
      dedupExerciseByKey @T (party, 0) Poke with n = 1
      newCIF <- getCommandsInFlight
      let changedCIF = Map.size (Map.filterWithKey (\k _ -> not (Map.member k priorCIF)) newCIF)
      if (changedCIF == 4)
        then pure ()
        else error $ show changedCIF <> " new commands in flight instead of 4"
    put (-1) -- just introducing some chaos
  registeredTemplates = RegisteredTemplates [registeredTemplate @T]
  heartbeat = None

data RetryState = RetryState
  { pendingRetries : Map.Map CommandId (Int, [Command])
  , queuedRetry : Optional [Command]
  }

data Lens t a = Lens { getter : t -> a, setter : (a -> a) -> t -> t }

infixr 9 @@
(@@) : Lens h n -> Lens n a -> Lens h a
hn @@ na = Lens (na.getter . hn.getter) (hn.setter . na.setter)

_1 : Lens (a, b) a
_1 = Lens fst (\f (a, b) -> (f a, b))

_2 : Lens (a, b) b
_2 = Lens snd (\f (a, b) -> (a, f b))

pendingRetries' : Lens RetryState (Map.Map CommandId (Int, [Command]))
pendingRetries' = Lens pendingRetries (\f s -> s { pendingRetries = f s.pendingRetries })

infix 4 %=
(%=) : ActionState s m => Lens s a -> (a -> a) -> m ()
(%=) Lens { setter } = modify . setter

use : (ActionState s m, Functor m) => Lens s a -> m a
use Lens { getter } = getter <$> get

bracketRetry : Int -> Lens s RetryState -> Trigger s -> Trigger s
bracketRetry retries rs trigger =
  let updateState msg = do
        case msg of
          MCompletion (Completion { commandId, status }) -> case status of
            Succeeded {} -> rs @@ pendingRetries' %= Map.delete commandId
            Failed {} -> rs %= \s ->
              optional s (enqueueRetry s commandId)
                $ Map.lookup commandId s.pendingRetries
          MTransaction {} -> pure ()
        -- NB: might be worth *not* performing the updateState on msg if a retry was enqueued
        trigger.updateState msg

      rule party = do
        -- TODO use queue
        trigger.rule party

      enqueueRetry s commandId (retries, commands) = RetryState with
        pendingRetries = (if retries <= 1
                          then Map.delete commandId
                          else Map.insert commandId (retries - 1, commands)) s.pendingRetries
        queuedRetry = Some commands

  in trigger with updateState; rule

test = do
  alice <- Script.allocateParty "Alice"
  tId <- submit alice do Script.createCmd T with party = alice, count = 1
  let activeContracts = toACS tId
  let commandsInFlight = Map.empty
  (endCount, commands) <- testRule trigger alice activeContracts commandsInFlight 1
  assertEq endCount (-1)
  let flatCommands = flattenCommands commands
  assertCreateCmd flatCommands $ \T { party, count } -> do
    assertEq party alice
    assertEq count 1
  assertExerciseCmd flatCommands $ \(cid, choiceArg) -> do
    assertEq cid tId
    assertEq choiceArg (Poke 0)
  assertExerciseByKeyCmd @T flatCommands $ \(k, choiceArg) -> do
    assertEq k (alice, 0)
    assertEq choiceArg (Poke 1)
  pure ()
