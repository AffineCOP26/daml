-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0


module Rule where

import DA.Action
import DA.Action.State.Class
import DA.Assert
import DA.Foldable (forA_)
import qualified DA.Next.Map as Map
import Daml.Trigger
import Daml.Trigger.Assert
import qualified Daml.Script as Script

template T
  with
    party : Party
    count : Int
  where
    signatory party
    key (party, count) : (Party, Int)
    maintainer key._1

    nonconsuming choice Poke : ()
      with
        n : Int
      controller party
        do
          pure ()

trigger : Trigger Int
trigger = Trigger with
  initialize = pure 0
  updateState = \_msg -> put . length =<< query @T
  rule = \party -> do
    count <- get
    when (count == 1) do
      priorCIF <- getCommandsInFlight
      -- Create two additional T.
      dedupCreate T with party, count
      dedupCreate T with party, count = succ count
      -- Exercise a choice
      ts <- query @T
      let [(tId, _)] = ts
      dedupExercise tId Poke with n = 0
      -- Exercise a choice by key
      dedupExerciseByKey @T (party, 0) Poke with n = 1
      newCIF <- getCommandsInFlight
      let changedCIF = Map.size (Map.filterWithKey (\k _ -> not (Map.member k priorCIF)) newCIF)
      if (changedCIF == 4)
        then pure ()
        else error $ show changedCIF <> " new commands in flight instead of 4"
    put (-1) -- just introducing some chaos
  registeredTemplates = RegisteredTemplates [registeredTemplate @T]
  heartbeat = None

data RetryState = RetryState
  { pendingRetries : Map.Map CommandId (Int, [Command])
  , queuedRetry : Optional (CommandId, [Command])
  }

data Lens t a = Lens { getter : t -> a, setter : (a -> a) -> t -> t }

infixr 9 @@
(@@) : Lens h n -> Lens n a -> Lens h a
hn @@ na = Lens (na.getter . hn.getter) (hn.setter . na.setter)

_1 : Lens (a, b) a
_1 = Lens fst (\f (a, b) -> (f a, b))

_2 : Lens (a, b) b
_2 = Lens snd (\f (a, b) -> (a, f b))

pendingRetries' : Lens RetryState (Map.Map CommandId (Int, [Command]))
pendingRetries' = Lens pendingRetries (\f s -> s { pendingRetries = f s.pendingRetries })

queuedRetry' : Lens RetryState (Optional (CommandId, [Command]))
queuedRetry' = Lens queuedRetry (\f s -> s { queuedRetry = f s.queuedRetry })

infix 4 .=, %=
(.=) : ActionState s m => Lens s a -> a -> m ()
(.=) Lens { setter } = modify . setter . const
(%=) : ActionState s m => Lens s a -> (a -> a) -> m ()
(%=) Lens { setter } = modify . setter

use : (ActionState s m, Functor m) => Lens s a -> m a
use Lens { getter } = getter <$> get

bracketRetry : Int -> Lens s RetryState -> Trigger s -> Trigger s
bracketRetry retries rs trigger =
  let updateState msg = do
        case msg of
          MCompletion (Completion { commandId, status }) -> case status of
            Succeeded {} -> rs @@ pendingRetries' %= Map.delete commandId
            Failed {} -> rs %= \s ->
              optional s (enqueueRetry s commandId)
                $ Map.lookup commandId s.pendingRetries
          MTransaction {} -> pure ()
        -- NB: might be worth *not* performing the updateState on msg if a retry was enqueued
        trigger.updateState msg

      rule party = do
        retry <- use (rs @@ queuedRetry')
        retry `forA_` \(oldCmdId, cmds) -> do
          -- the Failed would have removed the 2nd argument from the internal
          -- state; I have no way to rederive it
          newCmdId <- emitCommands cmds []
          -- fixing the command ID now simplifies the update with
          -- commands-in-flight later
          rs @@ pendingRetries' %= \m ->
            optional m (\v -> Map.insert newCmdId v $ Map.delete oldCmdId m)
              $ Map.lookup oldCmdId m
          rs @@ queuedRetry' .= None

        trigger.rule party -- actually running the rule

        cif <- getCommandsInFlight
        -- every *new* command joins the retry list
        rs @@ pendingRetries' %=
          Map.merge (\_ cmds -> Some (retries, cmds)) (const Some) (\_ -> const Some) cif

      enqueueRetry s commandId (retriesLeft, commands) = RetryState with
        pendingRetries = (if retriesLeft <= 1
                          then Map.delete commandId
                          else Map.insert commandId (retriesLeft - 1, commands)) s.pendingRetries
        -- This is why we save the commands in the map, instead of using
        -- getCommandsInFlight: by the time we get to the rule where we can use
        -- getCommandsInFlight, the association with commandId is gone.
        queuedRetry = Some (commandId, commands)

  in trigger with updateState; rule

test = do
  alice <- Script.allocateParty "Alice"
  tId <- submit alice do Script.createCmd T with party = alice, count = 1
  let activeContracts = toACS tId
  let commandsInFlight = Map.empty
  (endCount, commands) <- testRule trigger alice activeContracts commandsInFlight 1
  assertEq endCount (-1)
  let flatCommands = flattenCommands commands
  assertCreateCmd flatCommands $ \T { party, count } -> do
    assertEq party alice
    assertEq count 1
  assertExerciseCmd flatCommands $ \(cid, choiceArg) -> do
    assertEq cid tId
    assertEq choiceArg (Poke 0)
  assertExerciseByKeyCmd @T flatCommands $ \(k, choiceArg) -> do
    assertEq k (alice, 0)
    assertEq choiceArg (Poke 1)
  pure ()
